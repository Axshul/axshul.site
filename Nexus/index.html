<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nexus - Infinite Canvas Drawing App | Create Diagrams & Sketches Online</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Nexus is a powerful infinite canvas drawing app for creating diagrams, sketches, and visual content. Auto-saves to URL, supports shapes, text, arrows, and collaborative sharing. Created by Axshul.">
    <meta name="keywords" content="drawing app, infinite canvas, diagram tool, sketch app, visual collaboration, online whiteboard, drawing software, design tool, Axshul">
    <meta name="author" content="Axshul">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yoursite.com/Nexus/">
    <meta property="og:title" content="Nexus - Infinite Canvas Drawing App">
    <meta property="og:description" content="Create diagrams and sketches on an infinite dark canvas. Auto-saves to URL for easy sharing. Built by Axshul.">
    <meta property="og:image" content="https://yoursite.com/assets/img/nexus-preview.png">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://yoursite.com/Nexus/">
    <meta property="twitter:title" content="Nexus - Infinite Canvas Drawing App">
    <meta property="twitter:description" content="Create diagrams and sketches on an infinite dark canvas. Auto-saves to URL for easy sharing. Built by Axshul.">
    <meta property="twitter:image" content="https://yoursite.com/assets/img/nexus-preview.png">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://yoursite.com/Nexus/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../assets/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon_io/favicon-16x16.png">
    
    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Nexus",
        "description": "Infinite canvas drawing app for creating diagrams, sketches, and visual content",
        "url": "https://yoursite.com/Nexus/",
        "author": {
            "@type": "Person",
            "name": "Axshul"
        },
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Infinite canvas drawing",
            "Auto-save to URL",
            "Shape tools (rectangles, circles, arrows)",
            "Text editing",
            "Image upload",
            "Collaborative sharing",
            "Undo/Redo functionality",
            "Export to PNG/SVG"
        ]
    }
    </script>
    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Roboto+Mono&family=Playfair+Display&display=swap"
        rel="stylesheet">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/fabric-eraser-brush@1.1.0/dist/index.js"></script>
    <!-- LZ-String for compression -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.5.0/lz-string.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        :root {
            --bg-color: #000000;
            --panel-bg: rgba(18, 18, 18, 0.9);
            --panel-border: #2A2A2A;
            --accent-color: #0077FF;
            --accent-green: #00CC88;
            --text-main: #ECECEC;
            --text-dim: #999999;
            --transition-speed: 0.15s;
            --sidebar-width: 260px;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle, #1A1A1A 1px, transparent 1px);
            background-size: 30px 30px;
        }

        /* Top Toolbar */
        .toolbar {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 6px;
            display: flex;
            gap: 2px;
            z-index: 100;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8);
        }

        .tool-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-speed);
            position: relative;
        }

        .tool-btn:hover {
            color: var(--text-main);
            background: rgba(255, 255, 255, 0.04);
        }

        .tool-btn.active {
            color: var(--accent-color);
            background: rgba(0, 119, 255, 0.08);
        }

        .tool-btn kbd {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 8px;
            opacity: 0.5;
            font-family: inherit;
        }

        .divider {
            width: 1px;
            height: 20px;
            background: var(--panel-border);
            margin: 0 6px;
            align-self: center;
        }

        /* Sidebar Property Panel */
        .sidebar {
            position: absolute;
            top: 80px;
            left: 15px;
            width: var(--sidebar-width);
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 16px;
            z-index: 200;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 160px);
            overflow-y: auto;
            transition: opacity 0.2s, transform 0.2s;
        }

        .sidebar.hidden {
            display: none;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .property-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .property-label {
            font-size: 13px;
            color: var(--text-main);
        }

        .swatch-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .swatch {
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.1s;
        }

        .swatch:hover {
            transform: scale(1.15);
        }

        .swatch.active {
            border: 2px solid var(--accent-color);
        }

        /* Control inputs */
        input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--panel-border);
            border-radius: 2px;
            appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            background: #1A1A1A;
            border: 1px solid var(--panel-border);
            color: var(--text-main);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
        }

        /* Bottom Status Bar */
        .bottom-bar {
            position: absolute;
            bottom: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 100;
        }

        .bottom-group {
            display: flex;
            gap: 10px;
            pointer-events: all;
        }

        .status-indicator {
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 6px 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: #444;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .status-dot.active {
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green);
        }

        /* Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
        }

        .help-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        /* Global Color Selector */
        .global-color-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid var(--panel-border);
        }

        .global-color-input {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: none;
            cursor: pointer;
            outline: none;
        }

        .global-color-label {
            font-size: 11px;
            color: var(--text-dim);
            font-weight: 500;
        }

        /* Creator Attribution */
        .creator-badge {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: var(--panel-bg);
            backdrop-filter: blur(12px);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            padding: 6px 12px;
            font-size: 11px;
            color: var(--text-dim);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .creator-badge:hover {
            color: var(--text-main);
            border-color: var(--accent-color);
        }

        /* Empty State */
        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            color: var(--text-dim);
            opacity: 0.5;
        }

        /* Improved responsive design */
        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                max-width: 90vw;
            }
            
            .sidebar {
                width: calc(100vw - 30px);
                left: 15px;
                right: 15px;
            }
            
            .creator-badge {
                display: none;
            }
        }

        /* Better focus states for accessibility */
        .tool-btn:focus,
        input:focus,
        select:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Loading state */
        .loading {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="nexus-canvas"></canvas>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button class="tool-btn active" data-tool="select" title="Selection">
            <i data-lucide="mouse-pointer-2"></i><kbd>V</kbd>
        </button>
        <button class="tool-btn" data-tool="hand" title="Pan">
            <i data-lucide="hand"></i><kbd>H</kbd>
        </button>
        <div class="divider"></div>
        
        <!-- Global Color Selector -->
        <div class="global-color-selector">
            <span class="global-color-label">Color</span>
            <input type="color" id="global-color-picker" class="global-color-input" value="#0077FF" title="Global Color">
        </div>
        <div class="divider"></div>
        
        <button class="tool-btn" data-tool="text" title="Text">
            <i data-lucide="type"></i><kbd>T</kbd>
        </button>
        <button class="tool-btn" data-tool="rect" title="Rectangle">
            <i data-lucide="square"></i><kbd>R</kbd>
        </button>
        <button class="tool-btn" data-tool="circle" title="Circle">
            <i data-lucide="circle"></i><kbd>O</kbd>
        </button>
        <button class="tool-btn" data-tool="arrow" title="Arrow">
            <i data-lucide="move-up-right"></i><kbd>A</kbd>
        </button>
        <button class="tool-btn" data-tool="pencil" title="Pencil">
            <i data-lucide="pencil"></i><kbd>P</kbd>
        </button>
        <button class="tool-btn" data-tool="eraser" title="Eraser">
            <i data-lucide="eraser"></i><kbd>E</kbd>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="img-upload-btn" title="Image">
            <i data-lucide="image"></i>
            <input type="file" id="img-input" accept="image/*" style="display:none">
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="clear-btn" title="Clear All">
            <i data-lucide="trash-2"></i>
        </button>
    </div>

    <!-- Sidebar Property Panel -->
    <div class="sidebar hidden" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-title">Appearance</div>
            <div class="swatch-grid" id="swatch-grid">
                <div class="swatch" style="background: #0077FF" data-color="#0077FF"></div>
                <div class="swatch" style="background: #8A2BE2" data-color="#8A2BE2"></div>
                <div class="swatch" style="background: #00CC88" data-color="#00CC88"></div>
                <div class="swatch" style="background: #FFD700" data-color="#FFD700"></div>
                <div class="swatch" style="background: #FF4500" data-color="#FF4500"></div>
                <div class="swatch" style="background: #FFFFFF" data-color="#FFFFFF"></div>
                <div class="swatch" style="background: #333333" data-color="#333333"></div>
                <div class="swatch" style="background: #666666" data-color="#666666"></div>
                <div class="swatch" style="background: #FF69B4" data-color="#FF69B4"></div>
                <div class="swatch" style="background: #00FFFF" data-color="#00FFFF"></div>
                <div class="swatch" style="background: #7FFF00" data-color="#7FFF00"></div>
                <div class="swatch" style="background: transparent; border: 1px dashed #555" data-color="transparent">
                </div>
            </div>
            <div class="property-row">
                <input type="color" id="custom-color-picker"
                    style="width: 100%; height: 30px; border: none; border-radius: 4px; background: none; cursor: pointer;">
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Stroke & Style</div>
            <div class="property-row">
                <span class="property-label">Thickness</span>
                <input type="range" id="stroke-width" min="1" max="20" value="2">
            </div>
            <div class="property-row">
                <span class="property-label">Opacity</span>
                <input type="range" id="opacity" min="0" max="100" value="100">
            </div>
            <div class="property-row">
                <span class="property-label">Style</span>
                <select id="stroke-dash">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                </select>
            </div>
            <div class="property-row">
                <span class="property-label">Glow</span>
                <input type="range" id="glow" min="0" max="40" value="0">
            </div>
        </div>

        <div class="sidebar-section" id="text-options" style="display:none">
            <div class="sidebar-title">Typography</div>
            <div class="property-row">
                <select id="font-family" style="width:100%">
                    <option value="Inter">Inter</option>
                    <option value="Roboto Mono">Roboto Mono</option>
                    <option value="Playfair Display">Playfair</option>
                    <option value="System-ui">System</option>
                </select>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Actions</div>
            <div class="property-row">
                <button class="tool-btn" id="bring-front" title="Bring to Front" style="flex:1"><i
                        data-lucide="layers-2"></i></button>
                <button class="tool-btn" id="send-back" title="Send to Back" style="flex:1"><i data-lucide="layers-2"
                        style="transform:rotate(180deg)"></i></button>
                <button class="tool-btn" id="lock-btn" title="Lock/Unlock" style="flex:1"><i
                        data-lucide="lock"></i></button>
                <button class="tool-btn" id="delete-btn" title="Delete" style="flex:1"><i data-lucide="x"></i></button>
            </div>
            <div class="property-row">
                <button class="tool-btn" id="group-btn" title="Group" style="flex:1"><i
                        data-lucide="combine"></i></button>
                <button class="tool-btn" id="ungroup-btn" title="Ungroup" style="flex:1"><i
                        data-lucide="split"></i></button>
            </div>
        </div>
    </div>

    <!-- Bottom Bar -->
    <div class="bottom-bar">
        <div class="bottom-group">
            <button class="tool-btn" id="undo-btn" title="Undo (Ctrl+Z)"><i data-lucide="undo-2"></i></button>
            <button class="tool-btn" id="redo-btn" title="Redo (Ctrl+Y)"><i data-lucide="redo-2"></i></button>
            <div class="divider"></div>
            <div class="status-indicator">
                <span id="zoom-level">100%</span>
            </div>
        </div>
        <div class="bottom-group">
            <button class="tool-btn" id="export-png" title="Export PNG"><i data-lucide="download"></i></button>
            <button class="tool-btn" id="export-svg" title="Export SVG"><i data-lucide="file-code"></i></button>
            <button class="tool-btn" id="copy-link" title="Copy Share Link"><i data-lucide="link"></i></button>
            <div class="status-indicator">
                <span id="save-status">Synced</span>
                <div class="status-dot" id="status-dot"></div>
            </div>
        </div>
    </div>

    <!-- Creator Badge -->
    <div class="creator-badge">
        <i data-lucide="palette"></i>
        <span>Created by Axshul</span>
    </div>

    <!-- Help Button -->
    <button class="tool-btn help-btn" id="help-toggle">
        <i data-lucide="help-circle"></i>
    </button>

    <!-- Help Overlay -->
    <div class="overlay" id="help-overlay">
        <div class="modal">
            <h2 style="margin-top:0; color: var(--accent-color)">Nexus</h2>
            <p>Draw, type, and create on an infinite dark canvas.</p>
            <p style="font-size: 12px; color: var(--text-dim); margin: 10px 0;">Created by <strong>Axshul</strong></p>
            <div style="text-align: left; margin: 20px 0; font-size: 14px; color: var(--text-dim)">
                <p>• <b>Auto-save:</b> Every 10 seconds, the URL updates with your changes.</p>
                <p>• <b>Sharing:</b> Simply copy the URL and share it. It's your save file.</p>
                <p>• <b>Global Color:</b> Use the color picker in the toolbar to set colors for all new objects.</p>
                <p>• <b>Shortcuts:</b> V (Select), T (Text), R (Rect), P (Pencil), Del (Delete).</p>
            </div>
            <button class="tool-btn" id="help-close"
                style="width: 100%; background: var(--accent-color); color: white; margin-top: 10px;">Got it</button>
        </div>
    </div>

    <!-- Empty State -->
    <div id="empty-state">
        <h1 style="font-weight: 200; letter-spacing: 0.2em; margin-bottom: 10px;">N E X U S</h1>
        <p>Start creating. Everything is auto-saved to this URL.</p>
    </div>

    <script>
        // --- Core Setup ---
        const canvas = new fabric.Canvas('nexus-canvas', {
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 'transparent',
            preserveObjectStacking: true,
            selection: true
        });

        // Initialize Lucide
        lucide.createIcons();

        // --- State Management ---
        const state = {
            currentTool: 'select',
            currentColor: '#0077FF',
            isPanning: false,
            zoom: 1,
            history: [],
            historyIndex: -1,
            isLocked: false,
            lastSave: 0
        };

        // UI References
        const sidebar = document.getElementById('sidebar');
        const toolBtns = document.querySelectorAll('.tool-btn[data-tool]');
        const swatchGrid = document.getElementById('swatch-grid');
        const customColorPicker = document.getElementById('custom-color-picker');
        const globalColorPicker = document.getElementById('global-color-picker');
        const strokeWidthInput = document.getElementById('stroke-width');
        const opacityInput = document.getElementById('opacity');
        const strokeDashInput = document.getElementById('stroke-dash');
        const fontFamilyInput = document.getElementById('font-family');
        const zoomLevelText = document.getElementById('zoom-level');
        const saveStatusText = document.getElementById('save-status');
        const statusDot = document.getElementById('status-dot');
        const emptyState = document.getElementById('empty-state');

        // --- UI Initialization ---
        function initUI() {
            // Tool selection
            toolBtns.forEach(btn => {
                btn.onclick = () => setTool(btn.dataset.tool);
            });

            // Swatches
            document.querySelectorAll('.swatch').forEach(swatch => {
                swatch.onclick = () => {
                    const color = swatch.dataset.color;
                    setColor(color);
                    
                    // If we have selected text objects, update their color immediately
                    const activeObjects = canvas.getActiveObjects();
                    activeObjects.forEach(obj => {
                        if (obj.type === 'i-text' || obj.type === 'text') {
                            obj.set('fill', color);
                            obj.set('stroke', 'transparent');
                            obj.set('strokeWidth', 0);
                        }
                    });
                    if (activeObjects.length) {
                        canvas.renderAll();
                        saveState();
                    }
                };
            });

            customColorPicker.oninput = (e) => {
                const color = e.target.value;
                setColor(color);
                
                // Immediate update for text objects
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        obj.set('fill', color);
                        obj.set('stroke', 'transparent');
                        obj.set('strokeWidth', 0);
                    }
                });
                if (activeObjects.length) {
                    canvas.renderAll();
                }
            };
            
            globalColorPicker.oninput = (e) => {
                const color = e.target.value;
                setColor(color);
                
                // Immediate update for text objects
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        obj.set('fill', color);
                        obj.set('stroke', 'transparent');
                        obj.set('strokeWidth', 0);
                    }
                });
                if (activeObjects.length) {
                    canvas.renderAll();
                }
            };

            // Property updates
            strokeWidthInput.oninput = (e) => updateActiveObjects('strokeWidth', parseInt(e.target.value));
            opacityInput.oninput = (e) => updateActiveObjects('opacity', parseInt(e.target.value) / 100);
            document.getElementById('glow').oninput = (e) => {
                const val = parseInt(e.target.value);
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (val === 0) obj.set('shadow', null);
                    else obj.set('shadow', new fabric.Shadow({
                        color: obj.stroke || state.currentColor,
                        blur: val,
                        offsetX: 0,
                        offsetY: 0
                    }));
                });
                canvas.renderAll();
                saveState();
            };
            strokeDashInput.onchange = (e) => {
                const val = e.target.value;
                let dash = [];
                if (val === 'dashed') dash = [10, 5];
                else if (val === 'dotted') dash = [2, 2];
                updateActiveObjects('strokeDashArray', dash);
            };
            fontFamilyInput.onchange = (e) => updateActiveObjects('fontFamily', e.target.value);

            // Action buttons
            document.getElementById('bring-front').onclick = () => {
                canvas.getActiveObjects().forEach(obj => canvas.bringToFront(obj));
                canvas.renderAll();
                saveState();
            };
            document.getElementById('send-back').onclick = () => {
                canvas.getActiveObjects().forEach(obj => canvas.sendToBack(obj));
                canvas.renderAll();
                saveState();
            };
            document.getElementById('delete-btn').onclick = deleteSelected;
            document.getElementById('lock-btn').onclick = toggleLock;
            document.getElementById('clear-btn').onclick = clearCanvas;
            document.getElementById('group-btn').onclick = groupSelected;
            document.getElementById('ungroup-btn').onclick = ungroupSelected;
            document.getElementById('undo-btn').onclick = undo;
            document.getElementById('redo-btn').onclick = redo;
            document.getElementById('export-png').onclick = exportPNG;
            document.getElementById('export-svg').onclick = exportSVG;
            document.getElementById('copy-link').onclick = copyShareLink;

            // Help overlay
            document.getElementById('help-toggle').onclick = () => document.getElementById('help-overlay').classList.add('visible');
            document.getElementById('help-close').onclick = () => document.getElementById('help-overlay').classList.remove('visible');

            // Image upload
            document.getElementById('img-upload-btn').onclick = handleImageBtn;
            document.getElementById('img-input').onchange = handleImageUpload;

            // Global Resize
            window.onresize = () => {
                canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
                canvas.renderAll();
            };
        }

        // --- Core Functions ---

        function createArrow(x, y) {
            const headLength = 15;
            const headWidth = 8;
            const points = [
                { x: 0, y: 0 },
                { x: 80, y: 0 },
                { x: 80 - headLength, y: -headWidth },
                { x: 80, y: 0 },
                { x: 80 - headLength, y: headWidth }
            ];
            
            const arrow = new fabric.Polyline(points, {
                left: x,
                top: y,
                stroke: state.currentColor,
                strokeWidth: parseInt(strokeWidthInput.value) || 2,
                fill: 'transparent',
                strokeLineCap: 'round',
                strokeLineJoin: 'round',
                originX: 'left',
                originY: 'center',
                objectCaching: false,
                selectable: true,
                evented: true
            });
            
            return arrow;
        }

        function setTool(tool) {
            state.currentTool = tool;
            toolBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));

            canvas.isDrawingMode = (tool === 'pencil' || tool === 'eraser');
            canvas.selection = (tool === 'select');
            canvas.defaultCursor = (tool === 'hand') ? 'grab' : (tool === 'select' ? 'default' : 'crosshair');

            if (canvas.isDrawingMode) {
                canvas.freeDrawingBrush = (tool === 'eraser')
                    ? new fabric.EraserBrush(canvas)
                    : new fabric.PencilBrush(canvas);
                canvas.freeDrawingBrush.width = parseInt(strokeWidthInput.value);
                if (tool === 'pencil') canvas.freeDrawingBrush.color = state.currentColor;
            }

            if (tool !== 'select') {
                canvas.discardActiveObject();
                canvas.renderAll();
            }
        }

        function setColor(color) {
            state.currentColor = color;
            customColorPicker.value = color === 'transparent' ? '#000000' : color;
            globalColorPicker.value = color === 'transparent' ? '#000000' : color;
            
            // Handle color updates for active objects
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                activeObjects.forEach(obj => {
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        // For text objects, only update fill (text color)
                        obj.set('fill', color);
                        // Ensure stroke is transparent for text
                        obj.set('stroke', 'transparent');
                    } else {
                        // For other objects, update both stroke and fill
                        if (obj.type !== 'line' && obj.type !== 'polyline') {
                            obj.set('fill', color === 'transparent' ? 'transparent' : color + '33');
                        }
                        obj.set('stroke', color);
                    }
                });
                canvas.renderAll();
                saveState();
            }

            if (state.currentTool === 'pencil' && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = color;
            }

            document.querySelectorAll('.swatch').forEach(s => {
                s.classList.toggle('active', s.dataset.color === color);
            });
        }

        function updateActiveObjects(prop, value) {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                activeObjects.forEach(obj => {
                    // Special handling for text objects
                    if (obj.type === 'i-text' || obj.type === 'text') {
                        if (prop === 'stroke') {
                            // Don't apply stroke to text, use fill instead
                            obj.set('fill', value);
                            obj.set('stroke', 'transparent');
                        } else if (prop === 'fill') {
                            obj.set('fill', value);
                        } else {
                            obj.set(prop, value);
                        }
                    } else {
                        // Handle other objects normally
                        if (prop === 'fill' && (obj.type === 'line' || obj.type === 'polyline')) return;
                        obj.set(prop, value);
                    }
                });
                canvas.renderAll();
                saveState();
            }
        }

        function groupSelected() {
            if (!canvas.getActiveObject()) return;
            if (canvas.getActiveObject().type !== 'activeSelection') return;
            canvas.getActiveObject().toGroup();
            canvas.requestRenderAll();
            saveState();
        }

        function ungroupSelected() {
            if (!canvas.getActiveObject()) return;
            if (canvas.getActiveObject().type !== 'group') return;
            canvas.getActiveObject().toActiveSelection();
            canvas.requestRenderAll();
            saveState();
        }

        function deleteSelected() {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                canvas.remove(...activeObjects);
                canvas.discardActiveObject();
                saveState();
            }
        }

        function toggleLock() {
            const activeObjects = canvas.getActiveObjects();
            activeObjects.forEach(obj => {
                obj.lockMovementX = !obj.lockMovementX;
                obj.lockMovementY = !obj.lockMovementY;
                obj.lockRotation = !obj.lockRotation;
                obj.lockScalingX = !obj.lockScalingX;
                obj.lockScalingY = !obj.lockScalingY;
                obj.editable = !obj.editable;
            });
            canvas.renderAll();
        }

        function clearCanvas() {
            if (confirm('Clear entire canvas?')) {
                canvas.clear();
                emptyState.style.display = 'block';
                saveState();
            }
        }

        // --- Pan & Zoom Logic ---

        canvas.on('mouse:wheel', (opt) => {
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
            state.zoom = zoom;
            zoomLevelText.textContent = Math.round(zoom * 100) + '%';
        });

        zoomLevelText.parentElement.onclick = () => {
            canvas.setZoom(1);
            canvas.viewportTransform[4] = 0;
            canvas.viewportTransform[5] = 0;
            canvas.requestRenderAll();
            state.zoom = 1;
            zoomLevelText.textContent = '100%';
        };

        canvas.on('mouse:down', (opt) => {
            const evt = opt.e;
            if (state.currentTool === 'hand' || evt.altKey || evt.button === 1) {
                state.isPanning = true;
                canvas.selection = false;
                state.lastPosX = evt.clientX;
                state.lastPosY = evt.clientY;
                canvas.setCursor('grabbing');
            }
        });

        canvas.on('mouse:move', (opt) => {
            if (state.isPanning) {
                const e = opt.e;
                const vpt = canvas.viewportTransform;
                vpt[4] += e.clientX - state.lastPosX;
                vpt[5] += e.clientY - state.lastPosY;
                canvas.requestRenderAll();
                state.lastPosX = e.clientX;
                state.lastPosY = e.clientY;
            }
        });

        canvas.on('mouse:up', () => {
            state.isPanning = false;
            canvas.selection = state.currentTool === 'select';
        });

        // --- History (Undo/Redo) ---

        function saveState() {
            if (state.isHistoryAction) return;

            // Optimization: Only serialize if there's an actual change
            const json = JSON.stringify(canvas.toDatalessJSON());

            if (state.historyIndex === -1 || state.history[state.historyIndex] !== json) {
                state.history = state.history.slice(0, state.historyIndex + 1);
                state.history.push(json);
                state.historyIndex++;

                // Limit history size
                if (state.history.length > 50) {
                    state.history.shift();
                    state.historyIndex--;
                }

                debounceSaveToURL();
                updateUndoRedoButtons();
            }
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.isHistoryAction = true;
                state.historyIndex--;
                loadStateFromJSON(state.history[state.historyIndex]);
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.isHistoryAction = true;
                state.historyIndex++;
                loadStateFromJSON(state.history[state.historyIndex]);
            }
        }

        function loadStateFromJSON(json) {
            canvas.loadFromJSON(json, () => {
                canvas.renderAll();
                state.isHistoryAction = false;
                updateUndoRedoButtons();
            });
        }

        // --- Persistence (The Magic) ---

        let saveTimeout;
        function debounceSaveToURL() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveToURL, 2000);
        }

        function saveToURL() {
            try {
                const json = JSON.stringify(canvas.toDatalessJSON());
                const compressed = LZString.compressToEncodedURIComponent(json);
                window.history.replaceState(null, null, '#' + compressed);

                statusDot.classList.add('active');
                saveStatusText.textContent = 'Synced';
                setTimeout(() => statusDot.classList.remove('active'), 1000);
            } catch (err) {
                console.error('Save failed', err);
                saveStatusText.textContent = 'Limit reached';
            }
        }

        function loadFromURL() {
            const hash = window.location.hash.substring(1);
            if (!hash) return;
            
            try {
                document.body.classList.add('loading');
                const decompressed = LZString.decompressFromEncodedURIComponent(hash);
                if (decompressed) {
                    canvas.loadFromJSON(decompressed, () => {
                        canvas.renderAll();
                        if (canvas.getObjects().length) emptyState.style.display = 'none';
                        saveState(); // Initialize history
                        document.body.classList.remove('loading');
                    });
                } else {
                    document.body.classList.remove('loading');
                }
            } catch (err) {
                console.error('Load failed', err);
                saveStatusText.textContent = 'Load failed';
                document.body.classList.remove('loading');
            }
        }

        function exportPNG() {
            const dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 });
            const link = document.createElement('a');
            link.download = 'nexus-export.png';
            link.href = dataURL;
            link.click();
        }

        function exportSVG() {
            const svg = canvas.toSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'nexus-export.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function copyShareLink() {
            navigator.clipboard.writeText(window.location.href);
            saveStatusText.textContent = 'Link Copied!';
            statusDot.classList.add('active');
            setTimeout(() => {
                saveStatusText.textContent = 'Synced';
                statusDot.classList.remove('active');
            }, 2000);
        }

        function handleImageBtn() {
            const choice = confirm("Upload image? (Cancel for URL)");
            if (choice) {
                document.getElementById('img-input').click();
            } else {
                const url = prompt("Image URL:");
                if (url && url.trim()) {
                    fabric.Image.fromURL(url.trim(), img => {
                        if (img.width && img.height) {
                            img.scaleToWidth(Math.min(300, window.innerWidth * 0.3));
                            canvas.add(img).centerObject(img).setActiveObject(img);
                            setTool('select');
                            saveState();
                        }
                    }, { 
                        crossOrigin: 'anonymous',
                        onError: () => {
                            alert('Failed to load image. Please check the URL.');
                        }
                    });
                }
            }
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file.');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = f => {
                fabric.Image.fromURL(f.target.result, img => {
                    if (img.width && img.height) {
                        img.scaleToWidth(Math.min(300, window.innerWidth * 0.3));
                        canvas.add(img).centerObject(img).setActiveObject(img);
                        setTool('select');
                        saveState();
                    }
                });
            };
            reader.onerror = () => {
                alert('Failed to read the image file.');
            };
            reader.readAsDataURL(file);
        }

        // --- Fabric Events ---
        canvas.on('selection:created', () => {
            sidebar.classList.remove('hidden');
            updateSidebarFromSelection();
        });
        canvas.on('selection:updated', () => {
            sidebar.classList.remove('hidden');
            updateSidebarFromSelection();
        });
        canvas.on('selection:cleared', () => {
            sidebar.classList.add('hidden');
            document.getElementById('text-options').style.display = 'none';
        });

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').style.opacity = (state.historyIndex > 0) ? '1' : '0.3';
            document.getElementById('redo-btn').style.opacity = (state.historyIndex < state.history.length - 1) ? '1' : '0.3';
        }

        function updateSidebarFromSelection() {
            const obj = canvas.getActiveObject();
            if (!obj) return;

            if (obj.strokeWidth) strokeWidthInput.value = obj.strokeWidth;
            if (obj.opacity !== undefined) opacityInput.value = obj.opacity * 100;

            if (obj.strokeDashArray) {
                if (obj.strokeDashArray[0] === 10) strokeDashInput.value = 'dashed';
                else if (obj.strokeDashArray[0] === 2) strokeDashInput.value = 'dotted';
                else strokeDashInput.value = 'solid';
            } else {
                strokeDashInput.value = 'solid';
            }

            if (obj.type === 'i-text' || obj.type === 'text') {
                document.getElementById('text-options').style.display = 'block';
                fontFamilyInput.value = obj.fontFamily || 'Inter';
                // For text objects, use fill color
                const textColor = obj.fill;
                if (textColor && typeof textColor === 'string') {
                    setColor(textColor);
                }
            } else {
                document.getElementById('text-options').style.display = 'none';
                // For other objects, prefer stroke color, fallback to fill
                const color = obj.stroke || obj.fill;
                if (color && typeof color === 'string') {
                    setColor(color);
                }
            }
        }

        canvas.on('mouse:down', (opt) => {
            if (state.currentTool === 'select' || state.currentTool === 'pencil' || state.currentTool === 'hand' || state.currentTool === 'eraser') return;

            const pointer = canvas.getPointer(opt.e);
            let obj;
            const strokeWidth = parseInt(strokeWidthInput.value) || 2;
            const common = {
                left: pointer.x,
                top: pointer.y,
                stroke: state.currentColor,
                strokeWidth: strokeWidth,
                fill: 'transparent',
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true
            };

            if (state.currentTool === 'rect') {
                const fillColor = state.currentColor === 'transparent' ? 'transparent' : state.currentColor + '33';
                obj = new fabric.Rect({ 
                    ...common, 
                    width: 100, 
                    height: 100, 
                    fill: fillColor,
                    rx: 5,
                    ry: 5
                });
            } else if (state.currentTool === 'circle') {
                const fillColor = state.currentColor === 'transparent' ? 'transparent' : state.currentColor + '33';
                obj = new fabric.Circle({ 
                    ...common, 
                    radius: 50, 
                    fill: fillColor 
                });
            } else if (state.currentTool === 'text') {
                obj = new fabric.IText('Type something...', { 
                    ...common, 
                    fill: state.currentColor, 
                    fontSize: 24, 
                    fontFamily: fontFamilyInput.value || 'Inter',
                    stroke: 'transparent',
                    strokeWidth: 0
                });
            } else if (state.currentTool === 'arrow') {
                obj = createArrow(pointer.x, pointer.y);
            }

            if (obj) {
                setTool('select');
                canvas.add(obj);
                canvas.setActiveObject(obj);
                canvas.requestRenderAll();
                saveState();
            }
        });

        // Keyboard Shortcuts
        window.onkeydown = (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
                if (e.key === 'x' && e.shiftKey) { e.preventDefault(); clearCanvas(); }
                return;
            }

            switch (e.key.toLowerCase()) {
                case 'v': setTool('select'); break;
                case 'h': setTool('hand'); break;
                case 't': setTool('text'); break;
                case 'r': setTool('rect'); break;
                case 'o': setTool('circle'); break;
                case 'a': setTool('arrow'); break;
                case 'p': setTool('pencil'); break;
                case 'e': setTool('eraser'); break;
                case 'delete':
                case 'backspace': deleteSelected(); break;
            }
        };

        // Initialize Everything
        initUI();
        setTool('select');
        
        // Load from URL when ready
        window.addEventListener('load', () => {
            loadFromURL();
            // Initialize first state for undo/redo
            setTimeout(() => {
                if (state.history.length === 0) {
                    saveState();
                }
            }, 100);
        });

        // Auto-save fallback with better timing
        setInterval(() => {
            if (canvas.getObjects().length > 0) {
                saveToURL();
            }
        }, 10000);

        // Canvas modification hooks with debouncing
        let modificationTimeout;
        const debouncedSaveState = () => {
            clearTimeout(modificationTimeout);
            modificationTimeout = setTimeout(saveState, 100);
        };

        canvas.on('object:modified', debouncedSaveState);
        canvas.on('object:added', () => {
            if (!state.isHistoryAction) {
                emptyState.style.display = 'none';
                debouncedSaveState();
            }
        });
        canvas.on('object:removed', debouncedSaveState);
        
        // Handle text editing mode
        canvas.on('text:editing:entered', (e) => {
            const textObj = e.target;
            // Ensure text color is preserved during editing
            if (textObj.fill) {
                textObj.set('stroke', 'transparent');
                textObj.set('strokeWidth', 0);
            }
        });
        
        canvas.on('text:editing:exited', (e) => {
            const textObj = e.target;
            // Ensure text properties are correct after editing
            textObj.set('stroke', 'transparent');
            textObj.set('strokeWidth', 0);
            canvas.renderAll();
            saveState();
        });
        
        // Better error handling for canvas operations
        canvas.on('error', (e) => {
            console.error('Canvas error:', e);
            saveStatusText.textContent = 'Error occurred';
        });
    </script>
</body>

</html>