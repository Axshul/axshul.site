<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEXUS for AI Engineers - Infinite Canvas Workflow Tool</title>

    <!-- SEO Meta Tags -->
    <meta name="description"
        content="NEXUS is a specialized infinite canvas tool for AI and N8N engineers to design, document, and present automation workflows. Created by Axshul.">
    <meta name="keywords"
        content="drawing app, infinite canvas, diagram tool, sketch app, visual collaboration, online whiteboard, drawing software, design tool, Axshul">
    <meta name="author" content="Axshul">
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yoursite.com/Nexus/">
    <meta property="og:title" content="NEXUS for AI Engineers">
    <meta property="og:description"
        content="Infinite canvas tool for AI and N8N engineers to design and present workflows. Built by Axshul.">
    <meta property="og:image" content="https://yoursite.com/assets/img/nexus-preview.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://yoursite.com/Nexus/">
    <meta property="twitter:title" content="NEXUS for AI Engineers">
    <meta property="twitter:description"
        content="Infinite canvas tool for AI and N8N engineers to design and present workflows. Built by Axshul.">
    <meta property="twitter:image" content="https://yoursite.com/assets/img/nexus-preview.png">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://yoursite.com/Nexus/">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../assets/favicon_io/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="../assets/favicon_io/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon_io/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon_io/favicon-16x16.png">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "NEXUS for AI Engineers",
        "description": "Specialized infinite canvas tool for AI and N8N engineers to design and present workflows",
        "url": "https://yoursite.com/Nexus/",
        "author": {
            "@type": "Person",
            "name": "Axshul"
        },
        "applicationCategory": "DesignApplication",
        "operatingSystem": "Web Browser",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "featureList": [
            "Infinite canvas drawing",
            "Auto-save to URL",
            "Shape tools (rectangles, circles, arrows)",
            "Text editing",
            "Image upload",
            "Collaborative sharing",
            "Undo/Redo functionality",
            "Export to PNG/SVG"
        ]
    }
    </script>
    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Roboto+Mono&family=Playfair+Display&display=swap"
        rel="stylesheet">
    <!-- Fabric.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://unpkg.com/fabric-eraser-brush@1.1.0/dist/index.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- n8n Workflow Preview CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2.0.0/webcomponents-loader.js"></script>
    <script src="https://www.unpkg.com/lit@2.0.0-rc.2/polyfill-support.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@n8n_io/n8n-demo-component/n8n-demo.bundled.js"></script>
    <style>
        :root {
            --bg-color: #0d0d0d;
            --panel-bg: rgba(23, 23, 23, 0.8);
            --panel-border: rgba(255, 255, 255, 0.08);
            --accent-color: #3b82f6;
            --accent-green: #10b981;
            --text-main: #f3f4f6;
            --text-dim: #9ca3af;
            --transition-speed: 0.2s;
            --sidebar-width: 280px;
            --shadow-lg: 0 10px 25px -5px rgba(0, 0, 0, 0.3), 0 8px 10px -6px rgba(0, 0, 0, 0.3);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle, #2a2a2a 1px, transparent 1px);
            background-size: 30px 30px;
        }

        /* Top Toolbar */
        .toolbar {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--panel-bg);
            backdrop-filter: blur(16px);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 8px;
            display: flex;
            gap: 4px;
            z-index: 100;
            box-shadow: var(--shadow-lg);
        }

        .tool-btn {
            background: transparent;
            border: none;
            color: var(--text-dim);
            padding: 10px 14px;
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-speed);
            position: relative;
        }

        .tool-btn:hover {
            color: var(--text-main);
            background: rgba(255, 255, 255, 0.06);
        }

        .tool-btn.active {
            color: #fff;
            background: var(--accent-color);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        .tool-btn kbd {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 8px;
            opacity: 0.5;
            font-family: inherit;
        }

        .divider {
            width: 1px;
            height: 20px;
            background: var(--panel-border);
            margin: 0 6px;
            align-self: center;
        }

        /* Sidebar Property Panel */
        .sidebar {
            position: absolute;
            top: 90px;
            left: 20px;
            width: var(--sidebar-width);
            background: var(--panel-bg);
            backdrop-filter: blur(16px);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 20px;
            z-index: 200;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
            gap: 24px;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
            transition: opacity 0.3s, transform 0.3s, visibility 0.3s;
        }

        .sidebar.hidden {
            display: none;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .sidebar-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .property-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .property-label {
            font-size: 13px;
            color: var(--text-main);
        }

        .swatch-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
        }

        .swatch {
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.1s;
        }

        .swatch:hover {
            transform: scale(1.15);
        }

        .swatch.active {
            border: 2px solid var(--accent-color);
        }

        /* Control inputs */
        input[type="range"] {
            flex: 1;
            height: 4px;
            background: var(--panel-border);
            border-radius: 2px;
            appearance: none;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
        }

        select {
            background: #1A1A1A;
            border: 1px solid var(--panel-border);
            color: var(--text-main);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
        }

        /* Bottom Status Bar */
        .bottom-bar {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 100;
        }

        .bottom-group {
            display: flex;
            gap: 10px;
            pointer-events: all;
        }

        .status-indicator {
            background: var(--panel-bg);
            backdrop-filter: blur(16px);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 8px 14px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 12px;
            color: var(--text-dim);
            box-shadow: var(--shadow-lg);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: #444;
            border-radius: 50%;
            transition: all 0.3s;
        }

        .status-dot.active {
            background: var(--accent-green);
            box-shadow: 0 0 10px var(--accent-green);
        }

        /* Overlays */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .overlay.visible {
            opacity: 1;
            pointer-events: all;
        }

        .modal {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 16px;
            padding: 30px;
            max-width: 400px;
            text-align: center;
        }

        .help-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        /* Global Color Selector */
        .global-color-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            border: 1px solid var(--panel-border);
        }

        .global-color-input {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            background: none;
            cursor: pointer;
            outline: none;
        }

        .global-color-label {
            font-size: 11px;
            color: var(--text-dim);
            font-weight: 500;
        }

        .quick-colors {
            display: flex;
            gap: 6px;
            margin-left: 4px;
        }

        .color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.1s;
        }

        .color-dot:hover {
            transform: scale(1.25);
        }

        /* Creator Attribution */
        .creator-badge {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: var(--panel-bg);
            backdrop-filter: blur(16px);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 8px 14px;
            font-size: 12px;
            color: var(--text-dim);
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: var(--shadow-lg);
            text-decoration: none;
            transition: all 0.2s;
        }

        .creator-badge:hover {
            color: var(--text-main);
            border-color: var(--accent-color);
        }

        /* Empty State */
        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            color: var(--text-dim);
            opacity: 0.5;
        }

        #node-library {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-height: 350px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .node-lib-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            padding: 10px;
            background: #1A1A1A;
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .node-lib-item:hover {
            background: #252525;
            border-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .node-lib-box {
            width: 44px;
            height: 44px;
            background: white;
            border: 2px solid #FF6C37;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .node-lib-box img {
            width: 26px;
            height: 26px;
            object-fit: contain;
        }

        .node-lib-name {
            font-size: 10px;
            color: var(--text-dim);
            text-align: center;
            font-weight: 500;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Improved responsive design */
        @media (max-width: 768px) {
            .toolbar {
                flex-wrap: wrap;
                max-width: 90vw;
            }

            .sidebar {
                width: calc(100vw - 30px);
                left: 15px;
                right: 15px;
            }

            .creator-badge {
                display: none;
            }
        }

        /* Better focus states for accessibility */
        .tool-btn:focus,
        input:focus,
        select:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 2px;
        }

        /* Loading state */
        .loading {
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="canvas-container">
        <canvas id="nexus-canvas"></canvas>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button class="tool-btn active" data-tool="select" title="Selection">
            <i data-lucide="mouse-pointer-2"></i><kbd>V</kbd>
        </button>
        <button class="tool-btn" data-tool="hand" title="Pan">
            <i data-lucide="hand"></i><kbd>H</kbd>
        </button>
        <div class="divider"></div>

        <!-- Global Color Selector -->
        <div class="global-color-selector">
            <input type="color" id="global-color-picker" class="global-color-input" value="#0077FF"
                title="Custom Color">
            <div class="quick-colors">
                <div class="color-dot" style="background: #0077FF" data-color="#0077FF"></div>
                <div class="color-dot" style="background: #00CC88" data-color="#00CC88"></div>
                <div class="color-dot" style="background: #FF6C37" data-color="#FF6C37"></div>
                <div class="color-dot" style="background: #FFFFFF" data-color="#FFFFFF"></div>
            </div>
        </div>
        <div class="divider"></div>

        <button class="tool-btn" data-tool="text" title="Text">
            <i data-lucide="type"></i><kbd>T</kbd>
        </button>
        <button class="tool-btn" data-tool="workflow" title="n8n Node / Showcase">
            <i data-lucide="box"></i><kbd>W</kbd>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" data-tool="rect" title="Rectangle">
            <i data-lucide="square"></i><kbd>R</kbd>
        </button>
        <button class="tool-btn" data-tool="circle" title="Circle">
            <i data-lucide="circle"></i><kbd>O</kbd>
        </button>
        <button class="tool-btn" data-tool="triangle" title="Triangle">
            <i data-lucide="triangle"></i>
        </button>
        <button class="tool-btn" data-tool="diamond" title="Diamond">
            <i data-lucide="diamond"></i>
        </button>
        <button class="tool-btn" data-tool="hexagon" title="Hexagon">
            <i data-lucide="hexagon"></i>
        </button>
        <button class="tool-btn" data-tool="frame" title="Add Slide Frame">
            <i data-lucide="monitor-play"></i>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" data-tool="arrow" title="Arrow">
            <i data-lucide="move-up-right"></i><kbd>A</kbd>
        </button>
        <button class="tool-btn" data-tool="pencil" title="Pencil">
            <i data-lucide="pencil"></i><kbd>P</kbd>
        </button>
        <button class="tool-btn" data-tool="highlighter" title="Highlighter">
            <i data-lucide="highlighter"></i>
        </button>
        <button class="tool-btn" data-tool="eraser" title="Eraser">
            <i data-lucide="eraser"></i><kbd>E</kbd>
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="img-upload-btn" title="Image">
            <i data-lucide="image"></i>
            <input type="file" id="img-input" accept="image/*" style="display:none">
        </button>
        <div class="divider"></div>
        <button class="tool-btn" id="present-btn" title="Presentation Mode">
            <i data-lucide="play"></i>
        </button>
        <button class="tool-btn" id="clear-btn" title="Clear All">
            <i data-lucide="trash-2"></i>
        </button>
    </div>

    <!-- Sidebar Property Panel -->
    <div class="sidebar hidden" id="sidebar">
        <!-- Content Editor (Contextual) -->
        <div class="sidebar-section" id="edit-section"
            style="display:none; background: rgba(0, 119, 255, 0.05); padding: 10px; border-radius: 8px; border: 1px solid rgba(0, 119, 255, 0.2);">
            <div class="sidebar-title" id="edit-title">Node Editor</div>
            <p style="font-size: 10px; color: var(--text-dim); margin: 0 0 8px 0;">Paste N8N Node JSON below to render
                it.</p>
            <textarea id="edit-textarea" placeholder='{"nodes": [...]}'
                style="width: 100%; height: 150px; background: #1A1A1A; border: 1px solid var(--panel-border); color: var(--text-main); padding: 8px; border-radius: 4px; font-family: 'Roboto Mono', monospace; font-size: 12px; resize: vertical; margin-bottom: 10px;"></textarea>
            <button class="tool-btn" id="save-content-btn"
                style="width: 100%; background: var(--accent-color); color: white; justify-content: center;">Apply
                Changes</button>
        </div>

        <div class="sidebar-section" id="image-section">
            <div class="sidebar-title">Assets</div>
            <div class="property-row">
                <button class="tool-btn" id="sidebar-upload-btn"
                    style="flex:1; background: rgba(255,255,255,0.05); border: 1px dashed var(--panel-border); font-size: 11px;">
                    <i data-lucide="upload-cloud" style="width:14px; margin-right:6px"></i> Upload Image
                </button>
                <button class="tool-btn" id="sidebar-url-btn"
                    style="flex:1; background: rgba(255,255,255,0.05); border: 1px dashed var(--panel-border); font-size: 11px;">
                    <i data-lucide="link" style="width:14px; margin-right:6px"></i> From URL
                </button>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Appearance</div>
            <div class="swatch-grid" id="swatch-grid">
                <div class="swatch" style="background: #0077FF" data-color="#0077FF"></div>
                <div class="swatch" style="background: #8A2BE2" data-color="#8A2BE2"></div>
                <div class="swatch" style="background: #00CC88" data-color="#00CC88"></div>
                <div class="swatch" style="background: #FFD700" data-color="#FFD700"></div>
                <div class="swatch" style="background: #FF4500" data-color="#FF4500"></div>
                <div class="swatch" style="background: #FFFFFF" data-color="#FFFFFF"></div>
                <div class="swatch" style="background: #333333" data-color="#333333"></div>
                <div class="swatch" style="background: #666666" data-color="#666666"></div>
                <div class="swatch" style="background: #FF69B4" data-color="#FF69B4"></div>
                <div class="swatch" style="background: #00FFFF" data-color="#00FFFF"></div>
                <div class="swatch" style="background: #7FFF00" data-color="#7FFF00"></div>
                <div class="swatch" style="background: transparent; border: 1px dashed #555" data-color="transparent">
                </div>
            </div>
            <div class="property-row">
                <input type="color" id="custom-color-picker"
                    style="width: 100%; height: 30px; border: none; border-radius: 4px; background: none; cursor: pointer;">
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Stroke & Style</div>
            <div class="property-row">
                <span class="property-label">Thickness</span>
                <input type="range" id="stroke-width" min="1" max="20" value="2">
            </div>
            <div class="property-row">
                <span class="property-label">Opacity</span>
                <input type="range" id="opacity" min="0" max="100" value="100">
            </div>
            <div class="property-row">
                <span class="property-label">Line Style</span>
                <select id="stroke-dash">
                    <option value="solid">Solid</option>
                    <option value="dashed">Dashed</option>
                    <option value="dotted">Dotted</option>
                </select>
            </div>
            <div class="property-row" id="arrow-style-row" style="display:none">
                <span class="property-label">Arrow Mode</span>
                <select id="arrow-type">
                    <option value="straight">Straight</option>
                    <option value="curved">Curved</option>
                </select>
            </div>
            <div class="property-row">
                <span class="property-label">Glow</span>
                <input type="range" id="glow" min="0" max="40" value="0">
            </div>
        </div>

        <div class="sidebar-section" id="text-options" style="display:none">
            <div class="sidebar-title">Typography</div>
            <div class="property-row">
                <select id="font-family" style="width:100%">
                    <option value="Inter">Inter</option>
                    <option value="Roboto Mono">Roboto Mono</option>
                    <option value="Playfair Display">Playfair</option>
                    <option value="System-ui">System</option>
                </select>
            </div>
        </div>

        <div class="sidebar-section">
            <div class="sidebar-title">Actions</div>
            <div class="property-row">
                <button class="tool-btn" id="bring-front" title="Bring to Front" style="flex:1"><i
                        data-lucide="layers-2"></i></button>
                <button class="tool-btn" id="send-back" title="Send to Back" style="flex:1"><i data-lucide="layers-2"
                        style="transform:rotate(180deg)"></i></button>
                <button class="tool-btn" id="lock-btn" title="Lock/Unlock" style="flex:1"><i
                        data-lucide="lock"></i></button>
                <button class="tool-btn" id="delete-btn" title="Delete" style="flex:1"><i data-lucide="x"></i></button>
            </div>
            <div class="property-row">
                <button class="tool-btn" id="group-btn" title="Group" style="flex:1"><i
                        data-lucide="combine"></i></button>
                <button class="tool-btn" id="ungroup-btn" title="Ungroup" style="flex:1"><i
                        data-lucide="split"></i></button>
            </div>
            <div class="property-row">
                <button class="tool-btn" id="sidebar-import-json"
                    style="flex:1; background: rgba(0, 204, 136, 0.1); border: 1px solid rgba(0, 204, 136, 0.2); color: var(--accent-green);">
                    <i data-lucide="folder-up" style="width:14px; margin-right:6px"></i> Import Project
                </button>
            </div>
        </div>
    </div>

    <!-- Bottom Bar -->
    <div class="bottom-bar">
        <div class="bottom-group">
            <button class="tool-btn" id="undo-btn" title="Undo (Ctrl+Z)"><i data-lucide="undo-2"></i></button>
            <button class="tool-btn" id="redo-btn" title="Redo (Ctrl+Y)"><i data-lucide="redo-2"></i></button>
            <div class="divider"></div>
            <div class="status-indicator">
                <span id="zoom-level">100%</span>
            </div>
        </div>
        <div class="bottom-group">
            <button class="tool-btn" id="export-png" title="Export PNG"><i data-lucide="download"></i></button>
            <button class="tool-btn" id="export-svg" title="Export SVG"><i data-lucide="file-code"></i></button>
            <button class="tool-btn" id="export-json" title="Export JSON Project"><i
                    data-lucide="file-json"></i></button>
            <button class="tool-btn" id="import-json" title="Import JSON Project"><i
                    data-lucide="folder-up"></i></button>
            <div class="status-indicator">
                <span id="save-status">Local Only</span>
                <div class="status-dot" id="status-dot"></div>
            </div>
        </div>
    </div>

    <!-- Creator Badge -->
    <a href="https://axshul.site" target="_blank" class="creator-badge" style="text-decoration: none;">
        <i data-lucide="palette"></i>
        <span>Created by Axshul</span>
    </a>

    <!-- Permanent Branding -->
    <div
        style="position: absolute; top: 100px; right: 80px; font-family: 'Inter', sans-serif; text-align: right; pointer-events: none; user-select: none; z-index: 1;">
        <div style="font-weight: 800; font-size: 42px; letter-spacing: 0.4em; color: rgba(255,255,255,0.12);">NEXUS
        </div>
        <div
            style="font-weight: 400; font-size: 12px; letter-spacing: 0.2em; color: rgba(255,255,255,0.2); margin-top: -4px;">
            FOR AI ENGINEERS</div>
    </div>

    <!-- Help Button -->
    <button class="tool-btn help-btn" id="help-toggle">
        <i data-lucide="help-circle"></i>
    </button>

    <!-- Slide Navigation (Presentation Mode Only) -->
    <div id="slide-nav"
        style="display: none; position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: var(--panel-bg); backdrop-filter: blur(16px); border: 1px solid var(--panel-border); border-radius: 12px; padding: 10px 20px; z-index: 2000; gap: 20px; align-items: center; box-shadow: var(--shadow-lg);">
        <button class="tool-btn" id="prev-slide" title="Previous Slide"><i data-lucide="chevron-left"></i></button>
        <div id="slide-indicator"
            style="font-size: 14px; font-weight: 600; color: var(--text-main); min-width: 80px; text-align: center;">
            Slide 1 / 1</div>
        <button class="tool-btn" id="next-slide" title="Next Slide"><i data-lucide="chevron-right"></i></button>
    </div>

    <!-- Help Overlay -->
    <div class="overlay" id="help-overlay">
        <div class="modal">
            <h2 style="margin-top:0; color: var(--accent-color)">Nexus</h2>
            <p>Draw, type, and create on an infinite dark canvas.</p>
            <p style="font-size: 12px; color: var(--text-dim); margin: 10px 0;">Created by <strong>Axshul</strong></p>
            <div style="text-align: left; margin: 20px 0; font-size: 14px; color: var(--text-dim)">
                <p>• <b>JSON Workflow:</b> Import and export your projects via JSON files.</p>
                <p>• <b>Snap-to-Grid:</b> Professional alignment with 30px grid snapping.</p>
                <p>• <b>Quick Text:</b> Double-click anywhere to quickly add text.</p>
                <p>• <b>Global Color:</b> Use the color picker in the toolbar to set colors for all new objects.</p>
                <p>• <b>Shortcuts:</b> V (Select), T (Text), R (Rect), P (Pencil), Del (Delete).</p>
            </div>
            <button class="tool-btn" id="help-close"
                style="width: 100%; background: var(--accent-color); color: white; margin-top: 10px;">Got it</button>
        </div>
    </div>

    <!-- Empty State Info -->
    <div id="empty-state">
        <p>Start creating. Professional workflow design tool.</p>
    </div>

    <script>
        // --- Core Setup ---
        const canvas = new fabric.Canvas('nexus-canvas', {
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 'transparent',
            preserveObjectStacking: true,
            selection: true,
            perPixelTargeting: true,
            targetFindTolerance: 10
        });

        // Initialize Lucide
        lucide.createIcons();

        // --- State Management ---
        const state = {
            currentTool: 'select',
            currentColor: '#3b82f6',
            isPanning: false,
            zoom: 1,
            history: [],
            historyIndex: -1,
            isLocked: false,
            lastSave: 0,
            isPresenting: false,
            grid: 30,
            currentSlide: 0
        };

        // UI References
        const sidebar = document.getElementById('sidebar');
        const toolBtns = document.querySelectorAll('.tool-btn[data-tool]');
        const swatchGrid = document.getElementById('swatch-grid');
        const customColorPicker = document.getElementById('custom-color-picker');
        const globalColorPicker = document.getElementById('global-color-picker');
        const strokeWidthInput = document.getElementById('stroke-width');
        const opacityInput = document.getElementById('opacity');
        const strokeDashInput = document.getElementById('stroke-dash');
        const fontFamilyInput = document.getElementById('font-family');
        const zoomLevelText = document.getElementById('zoom-level');
        const saveStatusText = document.getElementById('save-status');
        const statusDot = document.getElementById('status-dot');
        const emptyState = document.getElementById('empty-state');

        // --- Node Library ---
        // (Library removed as per user request to use dynamic Node Showcase)
        const n8nNodes = [];


        function addNodeToCanvas(node) {
            fabric.Image.fromURL(node.icon, (img) => {
                img.scaleToWidth(40);

                const rect = new fabric.Rect({
                    width: 100,
                    height: 100,
                    fill: '#FFFFFF',
                    stroke: node.color || '#FF6C37',
                    strokeWidth: 3,
                    rx: 15,
                    ry: 15,
                    originX: 'center',
                    originY: 'center',
                    shadow: new fabric.Shadow({
                        color: 'rgba(0,0,0,0.3)',
                        blur: 10,
                        offsetX: 0,
                        offsetY: 4
                    })
                });

                const text = new fabric.Text(node.name, {
                    fontSize: 12,
                    fontFamily: 'Inter',
                    fill: '#333333',
                    originX: 'center',
                    originY: 'center',
                    top: 35
                });

                img.set({
                    originX: 'center',
                    originY: 'center',
                    top: -10
                });

                const group = new fabric.Group([rect, img, text], {
                    left: canvas.getCenter().left,
                    top: canvas.getCenter().top,
                    originX: 'center',
                    originY: 'center',
                    id: generateId(),
                    subTargetCheck: true
                });

                canvas.add(group);
                canvas.setActiveObject(group);
                saveState();
            }, { crossOrigin: 'anonymous' });
        }

        // --- UI Initialization ---
        function initUI() {
            // Tool selection
            toolBtns.forEach(btn => {
                btn.onclick = () => setTool(btn.dataset.tool);
            });

            // Swatches
            document.querySelectorAll('.swatch').forEach(swatch => {
                swatch.onclick = () => setColor(swatch.dataset.color);
            });

            customColorPicker.oninput = (e) => setColor(e.target.value);

            globalColorPicker.oninput = (e) => setColor(e.target.value);
            document.querySelectorAll('.color-dot').forEach(dot => {
                dot.onclick = () => setColor(dot.dataset.color);
            });

            // Property updates
            strokeWidthInput.oninput = (e) => updateActiveObjects('strokeWidth', parseInt(e.target.value));
            opacityInput.oninput = (e) => updateActiveObjects('opacity', parseInt(e.target.value) / 100);
            document.getElementById('glow').oninput = (e) => {
                const val = parseInt(e.target.value);
                const activeObjects = canvas.getActiveObjects();
                activeObjects.forEach(obj => {
                    if (val === 0) obj.set('shadow', null);
                    else obj.set('shadow', new fabric.Shadow({
                        color: obj.stroke || state.currentColor,
                        blur: val,
                        offsetX: 0,
                        offsetY: 0
                    }));
                });
                canvas.renderAll();
                saveState();
            };
            strokeDashInput.onchange = (e) => {
                const val = e.target.value;
                let dash = [];
                if (val === 'dashed') dash = [10, 5];
                else if (val === 'dotted') dash = [2, 2];
                updateActiveObjects('strokeDashArray', dash);
            };
            fontFamilyInput.onchange = (e) => updateActiveObjects('fontFamily', e.target.value);

            // Action buttons
            document.getElementById('bring-front').onclick = () => {
                canvas.getActiveObjects().forEach(obj => canvas.bringToFront(obj));
                canvas.renderAll();
                saveState();
            };
            document.getElementById('send-back').onclick = () => {
                canvas.getActiveObjects().forEach(obj => canvas.sendToBack(obj));
                canvas.renderAll();
                saveState();
            };
            document.getElementById('delete-btn').onclick = deleteSelected;
            document.getElementById('lock-btn').onclick = toggleLock;
            document.getElementById('clear-btn').onclick = clearCanvas;
            document.getElementById('group-btn').onclick = groupSelected;
            document.getElementById('ungroup-btn').onclick = ungroupSelected;
            document.getElementById('undo-btn').onclick = undo;
            document.getElementById('redo-btn').onclick = redo;
            document.getElementById('export-png').onclick = exportPNG;
            document.getElementById('export-svg').onclick = exportSVG;
            document.getElementById('export-json').onclick = exportJSON;
            document.getElementById('import-json').onclick = importJSON;
            document.getElementById('sidebar-import-json').onclick = importJSON;
            document.getElementById('present-btn').onclick = togglePresentation;

            document.getElementById('prev-slide').onclick = () => navigateSlide(-1);
            document.getElementById('next-slide').onclick = () => navigateSlide(1);

            // Help overlay
            document.getElementById('help-toggle').onclick = () => document.getElementById('help-overlay').classList.add('visible');
            document.getElementById('help-close').onclick = () => document.getElementById('help-overlay').classList.remove('visible');

            // Image upload
            document.getElementById('img-upload-btn').onclick = handleImageBtn;
            document.getElementById('sidebar-upload-btn').onclick = () => document.getElementById('img-input').click();
            document.getElementById('sidebar-url-btn').onclick = handleImageUrl;
            document.getElementById('img-input').onchange = handleImageUpload;

            document.getElementById('save-content-btn').onclick = () => {
                const obj = canvas.getActiveObject();
                if (!obj) return;
                const value = document.getElementById('edit-textarea').value;

                if (obj.type === 'workflow-node') {
                    try {
                        const json = JSON.parse(value);
                        obj.workflowData = json;
                        if (obj.domElement) {
                            obj.domElement.setAttribute('workflow', JSON.stringify(json));
                            // Force web component refresh
                            const clone = obj.domElement.cloneNode(true);
                            obj.domElement.parentNode.replaceChild(clone, obj.domElement);
                            obj.domElement = clone;
                            obj.syncDOM();
                        }
                        saveState();
                    } catch (e) {
                        alert('Invalid JSON');
                    }
                }
            };

            // Global Resize
            window.onresize = () => {
                canvas.setDimensions({ width: window.innerWidth, height: window.innerHeight });
                canvas.renderAll();
            };
        }

        // --- Fabric Extensions & ID Management ---
        fabric.Object.prototype.includeDefaultValues = true;
        fabric.Object.prototype.toObject = (function (toObject) {
            return function (propertiesToInclude) {
                return toObject.call(this, ['id'].concat(propertiesToInclude));
            };
        })(fabric.Object.prototype.toObject);

        fabric.Polyline.prototype.toObject = (function (toObject) {
            return function (propertiesToInclude) {
                return toObject.call(this, [
                    'x1', 'y1', 'x2', 'y2',
                    'startObjId', 'endObjId',
                    'startPort', 'endPort',
                    'arrowType'
                ].concat(propertiesToInclude));
            };
        })(fabric.Polyline.prototype.toObject);

        function generateId() {
            return 'obj_' + Math.random().toString(36).substr(2, 9);
        }

        // --- Core Functions ---

        const ports = [
            { id: 'top', x: 0.5, y: 0 },
            { id: 'bottom', x: 0.5, y: 1 },
            { id: 'left', x: 0, y: 0.5 },
            { id: 'right', x: 1, y: 0.5 }
        ];

        function getPortCoords(obj, portId) {
            const width = obj.width * obj.scaleX;
            const height = obj.height * obj.scaleY;
            const port = ports.find(p => p.id === portId);

            let x = (port.x - 0.5) * width;
            let y = (port.y - 0.5) * height;

            const rad = fabric.util.degreesToRadians(obj.angle);
            const rx = x * Math.cos(rad) - y * Math.sin(rad);
            const ry = x * Math.sin(rad) + y * Math.cos(rad);

            return {
                x: obj.left + rx,
                y: obj.top + ry
            };
        }

        function getNearestPort(obj, pointer) {
            const coords = [
                { id: 'top', ...getPortCoords(obj, 'top') },
                { id: 'bottom', ...getPortCoords(obj, 'bottom') },
                { id: 'left', ...getPortCoords(obj, 'left') },
                { id: 'right', ...getPortCoords(obj, 'right') }
            ];

            let nearest = coords[0];
            let minDist = Math.hypot(pointer.x - coords[0].x, pointer.y - coords[0].y);

            coords.forEach(c => {
                const dist = Math.hypot(pointer.x - c.x, pointer.y - c.y);
                if (dist < minDist) {
                    minDist = dist;
                    nearest = c;
                }
            });

            return nearest;
        }

        function createArrow(x1, y1, x2, y2) {
            const arrowType = document.getElementById('arrow-type').value || 'straight';
            const arrow = new fabric.Polyline([{ x: 0, y: 0 }], {
                stroke: state.currentColor,
                strokeWidth: parseInt(strokeWidthInput.value) || 2,
                fill: 'transparent',
                strokeLineCap: 'round',
                strokeLineJoin: 'round',
                originX: 'left',
                originY: 'center',
                objectCaching: false,
                selectable: true,
                evented: true,
                padding: 20,
                x1: x1,
                y1: y1,
                x2: x2 || x1,
                y2: y2 || y1,
                arrowType: arrowType,
                perPixelTargeting: false
            });
            updateArrow(arrow);
            return arrow;
        }

        function updateArrow(arrow) {
            if (!arrow.startObj && arrow.startObjId) {
                arrow.startObj = canvas.getObjects().find(o => o.id === arrow.startObjId);
            }
            if (!arrow.endObj && arrow.endObjId) {
                arrow.endObj = canvas.getObjects().find(o => o.id === arrow.endObjId);
            }

            let p1 = { x: arrow.x1, y: arrow.y1 };
            let p2 = { x: arrow.x2, y: arrow.y2 };

            if (arrow.startObj) p1 = getPortCoords(arrow.startObj, arrow.startPort);
            if (arrow.endObj) p2 = getPortCoords(arrow.endObj, arrow.endPort);

            const headLength = 15;
            const headWidth = 8;
            const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
            const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

            let points = [];
            if (arrow.arrowType === 'curved' && dist > 10) {
                // Approximate a curve using polyline points
                points.push({ x: 0, y: 0 });
                const curveHeight = Math.min(dist / 4, 50);
                for (let i = 1; i <= 20; i++) {
                    const t = i / 20;
                    const x = t * dist;
                    const y = Math.sin(t * Math.PI) * curveHeight;
                    points.push({ x, y });
                }
                const last = points[points.length - 1];
                points.push({ x: last.x - headLength, y: last.y - headWidth });
                points.push({ x: last.x, y: last.y });
                points.push({ x: last.x - headLength, y: last.y + headWidth });
            } else {
                points = [
                    { x: 0, y: 0 },
                    { x: dist, y: 0 },
                    { x: dist - headLength, y: -headWidth },
                    { x: dist, y: 0 },
                    { x: dist - headLength, y: headWidth }
                ];
            }

            arrow.set({
                x1: p1.x,
                y1: p1.y,
                x2: p2.x,
                y2: p2.y,
                left: p1.x,
                top: p1.y,
                points: points,
                angle: fabric.util.radiansToDegrees(angle)
            });
            arrow.setCoords();
        }

        function updateConnectedArrows(obj) {
            canvas.getObjects('polyline').forEach(arrow => {
                if (arrow.startObj === obj || arrow.endObj === obj) {
                    updateArrow(arrow);
                }
            });
        }


        // --- n8n Workflow Node Class ---
        fabric.WorkflowNode = fabric.util.createClass(fabric.Rect, {
            type: 'workflow-node',
            initialize: function (workflowData, options) {
                options = options || {};
                options.width = options.width || 120; // Default smaller size for single node
                options.height = options.height || 120;
                options.fill = 'rgba(255, 255, 255, 0.01)';
                options.stroke = 'rgba(255, 108, 55, 0.3)';
                options.strokeWidth = 1;
                options.rx = 15;
                options.ry = 15;
                options.originX = 'center';
                options.originY = 'center';

                this.callSuper('initialize', options);
                this.workflowData = workflowData || { nodes: [], connections: {} };

                this.on('added', () => this.createDOMElement());
                this.on('removed', () => this.removeDOMElement());
            },
            createDOMElement: function () {
                if (this.domElement) return;

                // Check if an element with this ID already exists (e.g. from a previous partial load)
                const existing = document.getElementById('node-overlay-' + this.id);
                if (existing) {
                    this.domElement = existing;
                    return;
                }

                this.domElement = document.createElement('n8n-demo');
                this.domElement.id = 'node-overlay-' + this.id;
                this.domElement.className = 'workflow-overlay';
                this.domElement.style.position = 'fixed';
                this.domElement.style.zIndex = '50';
                this.domElement.style.pointerEvents = 'all';
                this.domElement.style.borderRadius = '12px';
                this.domElement.style.overflow = 'hidden';
                this.domElement.style.boxSizing = 'border-box';
                this.domElement.style.background = '#121212';
                this.domElement.setAttribute('workflow', JSON.stringify(this.workflowData));
                document.body.appendChild(this.domElement);
                this.syncDOM();
            },
            removeDOMElement: function () {
                if (this.domElement) {
                    this.domElement.remove();
                    this.domElement = null;
                }
            },
            syncDOM: function () {
                if (!this.domElement) return;
                const vpt = canvas.viewportTransform;
                const zoom = canvas.getZoom();

                const point = new fabric.Point(this.left, this.top);
                const screenPoint = fabric.util.transformPoint(point, vpt);

                const width = this.width * this.scaleX * zoom;
                const height = this.height * this.scaleY * zoom;

                this.domElement.style.width = `${width}px`;
                this.domElement.style.height = `${height}px`;
                this.domElement.style.left = `${screenPoint.x - width / 2}px`;
                this.domElement.style.top = `${screenPoint.y - height / 2}px`;
                this.domElement.style.transform = `rotate(${this.angle}deg)`;

                // Toggle visibility if off-screen
                const isOffScreen = screenPoint.x + width / 2 < 0 || screenPoint.y + height / 2 < 0 ||
                    screenPoint.x - width / 2 > window.innerWidth || screenPoint.y - height / 2 > window.innerHeight;
                this.domElement.style.display = isOffScreen ? 'none' : 'block';
            },
            toObject: function () {
                return fabric.util.object.extend(this.callSuper('toObject'), {
                    workflowData: this.workflowData
                });
            }
        });

        fabric.WorkflowNode.fromObject = function (object, callback) {
            const node = new fabric.WorkflowNode(object.workflowData, object);
            node.set(object);
            callback(node);
        };
        fabric['workflow-node'] = fabric.WorkflowNode;

        function setTool(tool) {
            state.currentTool = tool;
            toolBtns.forEach(btn => btn.classList.toggle('active', btn.dataset.tool === tool));
            if (tool !== 'arrow') clearPorts();

            document.getElementById('arrow-style-row').style.display = (tool === 'arrow') ? 'flex' : 'none';

            canvas.isDrawingMode = (tool === 'pencil' || tool === 'eraser' || tool === 'highlighter');
            canvas.selection = (tool === 'select');
            canvas.skipTargetFind = (tool === 'hand');
            canvas.defaultCursor = (tool === 'hand') ? 'grab' : (tool === 'select' ? 'default' : 'crosshair');

            if (canvas.isDrawingMode) {
                if (tool === 'eraser') {
                    canvas.freeDrawingBrush = new fabric.EraserBrush(canvas);
                    canvas.freeDrawingBrush.width = parseInt(strokeWidthInput.value) * 2;
                } else if (tool === 'highlighter') {
                    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                    canvas.freeDrawingBrush.width = 30;
                    canvas.freeDrawingBrush.color = new fabric.Color(state.currentColor).setAlpha(0.3).toRgba();
                } else {
                    canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
                    canvas.freeDrawingBrush.width = parseInt(strokeWidthInput.value);
                    canvas.freeDrawingBrush.color = state.currentColor;
                    // Smoothing
                    canvas.freeDrawingBrush.decimate = 1.5;
                }
            }

            if (tool !== 'select') {
                canvas.discardActiveObject();
                canvas.renderAll();
            }
        }

        function applyColorToObject(obj, color) {
            if (!obj || !color || obj.type === 'activeSelection') return;

            if (obj.type === 'i-text' || obj.type === 'text') {
                obj.set({ fill: color, stroke: 'transparent', strokeWidth: 0 });
            } else if (obj.type === 'group') {
                obj.getObjects().forEach(child => {
                    if (['rect', 'circle', 'path', 'polygon', 'polyline'].includes(child.type)) {
                        child.set('stroke', color);
                        if (child.fill && child.fill !== 'transparent' && !['#ffffff', 'white'].includes(child.fill.toLowerCase())) {
                            try {
                                child.set('fill', new fabric.Color(color).setAlpha(0.2).toRgba());
                            } catch (e) { }
                        }
                    }
                });
            } else if (obj.type === 'polyline' || obj.type === 'line') {
                obj.set({ stroke: color, fill: 'transparent' });
            } else {
                obj.set('stroke', color);
                if (obj.fill && obj.fill !== 'transparent') {
                    try {
                        obj.set('fill', new fabric.Color(color).setAlpha(0.2).toRgba());
                    } catch (e) {
                        obj.set('fill', color);
                    }
                }
            }
        }

        function setColor(color, updateObjects = true) {
            if (!color) return;
            state.currentColor = color;

            // Update UI Pickers
            let hexColor = '#0077FF';
            try {
                if (color !== 'transparent' && color.startsWith('#')) {
                    hexColor = color;
                } else if (color !== 'transparent') {
                    hexColor = new fabric.Color(color).toHex();
                    if (!hexColor.startsWith('#')) hexColor = '#' + hexColor;
                }
            } catch (e) { }

            customColorPicker.value = hexColor;
            globalColorPicker.value = hexColor;

            if (updateObjects) {
                const activeObjects = canvas.getActiveObjects();
                if (activeObjects.length) {
                    activeObjects.forEach(obj => applyColorToObject(obj, color));
                    canvas.renderAll();
                    saveState();
                }
            }

            if (state.currentTool === 'pencil' && canvas.freeDrawingBrush) {
                canvas.freeDrawingBrush.color = color;
            }

            document.querySelectorAll('.swatch').forEach(s => {
                s.classList.toggle('active', s.dataset.color === color);
            });
            document.querySelectorAll('.color-dot').forEach(d => {
                d.style.boxShadow = (d.dataset.color === color) ? '0 0 0 2px var(--accent-color)' : 'none';
            });
        }

        function updateActiveObjects(prop, value) {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                activeObjects.forEach(obj => {
                    if (obj.type === 'activeSelection') {
                        obj.getObjects().forEach(child => {
                            if (prop === 'stroke' || prop === 'fill') applyColorToObject(child, value);
                            else child.set(prop, value);
                        });
                    } else {
                        if (prop === 'stroke' || prop === 'fill') applyColorToObject(obj, value);
                        else obj.set(prop, value);
                    }
                });
                canvas.renderAll();
                saveState();
            }
        }

        function groupSelected() {
            if (!canvas.getActiveObject()) return;
            if (canvas.getActiveObject().type !== 'activeSelection') return;
            canvas.getActiveObject().toGroup();
            canvas.requestRenderAll();
            saveState();
        }

        function ungroupSelected() {
            if (!canvas.getActiveObject()) return;
            if (canvas.getActiveObject().type !== 'group') return;
            canvas.getActiveObject().toActiveSelection();
            canvas.requestRenderAll();
            saveState();
        }

        function deleteSelected() {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length) {
                canvas.remove(...activeObjects);
                canvas.discardActiveObject();
                saveState();
            }
        }

        function togglePresentation() {
            state.isPresenting = !state.isPresenting;
            const btn = document.getElementById('present-btn');
            const slideNav = document.getElementById('slide-nav');
            btn.classList.toggle('active', state.isPresenting);

            btn.innerHTML = state.isPresenting ? '<i data-lucide="square"></i>' : '<i data-lucide="play"></i>';
            lucide.createIcons();

            if (state.isPresenting) {
                state.prePresentJson = JSON.stringify(canvas.toDatalessJSON([
                    'id', 'x1', 'y1', 'x2', 'y2', 'startObjId', 'endObjId', 'startPort', 'endPort', 'arrowType',
                    'workflowData', 'fontSize', 'lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'hasControls', 'editable'
                ]));

                canvas.getObjects().forEach(obj => {
                    obj._originalLockState = {
                        lX: obj.lockMovementX, lY: obj.lockMovementY, lR: obj.lockRotation,
                        sX: obj.lockScalingX, sY: obj.lockScalingY, hC: obj.hasControls, ed: obj.editable
                    };
                    obj.set({
                        lockMovementX: true, lockMovementY: true, lockRotation: true,
                        lockScalingX: true, lockScalingY: true, hasControls: false, editable: false
                    });
                });

                document.querySelector('.sidebar').classList.add('hidden');
                document.querySelector('.toolbar').style.opacity = '0.3';
                document.querySelector('.bottom-bar').style.opacity = '0.3';

                const forbiddenTools = ['workflow', 'arrow', 'image', 'trash-2', 'frame'];
                document.querySelectorAll('.tool-btn[data-tool], .tool-btn#img-upload-btn, .tool-btn#clear-btn').forEach(b => {
                    const tool = b.dataset.tool || b.id;
                    if (forbiddenTools.some(t => tool.includes(t))) {
                        b.style.display = 'none';
                    }
                });

                // Find slides
                state.slides = canvas.getObjects().filter(o => o.type === 'slide-frame').sort((a, b) => a.top - b.top || a.left - b.left);
                if (state.slides.length > 0) {
                    state.currentSlide = 0;
                    slideNav.style.display = 'flex';
                    updateSlideUI();
                    navigateSlide(0);
                }

                setTool('pencil');
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(e => console.log(e));
                }
            } else {
                document.querySelector('.toolbar').style.opacity = '1';
                document.querySelector('.bottom-bar').style.opacity = '1';
                document.querySelectorAll('.tool-btn').forEach(b => b.style.display = 'flex');
                slideNav.style.display = 'none';

                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }

                if (state.prePresentJson) {
                    loadStateFromJSON(state.prePresentJson);
                    state.prePresentJson = null;
                }

                setTool('select');
            }

            sidebar.classList.remove('library-open');
        }

        function navigateSlide(dir) {
            if (!state.slides || state.slides.length === 0) return;

            state.currentSlide = Math.max(0, Math.min(state.slides.length - 1, state.currentSlide + dir));
            const frame = state.slides[state.currentSlide];

            const zoom = Math.min(
                (canvas.width * 0.9) / (frame.width * frame.scaleX),
                (canvas.height * 0.9) / (frame.height * frame.scaleY)
            );

            canvas.setZoom(zoom);
            const vpt = canvas.viewportTransform;
            vpt[4] = canvas.width / 2 - (frame.left * zoom);
            vpt[5] = canvas.height / 2 - (frame.top * zoom);

            canvas.requestRenderAll();
            canvas.getObjects('workflow-node').forEach(node => node.syncDOM());
            updateSlideUI();
        }

        function updateSlideUI() {
            document.getElementById('slide-indicator').textContent = `Slide ${state.currentSlide + 1} / ${state.slides.length}`;
            document.getElementById('prev-slide').style.opacity = state.currentSlide === 0 ? '0.3' : '1';
            document.getElementById('next-slide').style.opacity = state.currentSlide === state.slides.length - 1 ? '0.3' : '1';
        }

        function toggleLock() {
            const activeObjects = canvas.getActiveObjects();
            if (activeObjects.length === 0) return;

            const isLocked = !activeObjects[0].lockMovementX;
            activeObjects.forEach(obj => {
                obj.lockMovementX = isLocked;
                obj.lockMovementY = isLocked;
                obj.lockRotation = isLocked;
                obj.lockScalingX = isLocked;
                obj.lockScalingY = isLocked;
                if (obj.type === 'i-text') obj.editable = !isLocked;
                obj.hasControls = !isLocked;
            });

            const lockBtn = document.getElementById('lock-btn');
            lockBtn.innerHTML = isLocked ? '<i data-lucide="lock"></i>' : '<i data-lucide="unlock"></i>';
            lockBtn.classList.toggle('active', isLocked);
            lucide.createIcons();
            canvas.renderAll();
            saveState();
        }

        function clearCanvas() {
            if (confirm('Clear entire canvas?')) {
                canvas.clear();
                emptyState.style.display = 'block';
                saveState();
            }
        }

        // --- Pan & Zoom Logic ---

        canvas.on('mouse:wheel', (opt) => {
            const delta = opt.e.deltaY;
            let zoom = canvas.getZoom();
            zoom *= 0.999 ** delta;
            if (zoom > 20) zoom = 20;
            if (zoom < 0.01) zoom = 0.01;
            canvas.zoomToPoint({ x: opt.e.offsetX, y: opt.e.offsetY }, zoom);
            opt.e.preventDefault();
            opt.e.stopPropagation();
            state.zoom = zoom;
            zoomLevelText.textContent = Math.round(zoom * 100) + '%';

            canvas.getObjects('workflow-node').forEach(node => node.syncDOM());
        });

        zoomLevelText.parentElement.onclick = () => {
            canvas.setZoom(1);
            canvas.viewportTransform[4] = 0;
            canvas.viewportTransform[5] = 0;
            canvas.requestRenderAll();
            state.zoom = 1;
            zoomLevelText.textContent = '100%';
        };

        canvas.on('mouse:down', (opt) => {
            const evt = opt.e;

            // Hide sidebar if clicking empty canvas
            if (!opt.target) {
                sidebar.classList.add('hidden');
            }

            if (state.currentTool === 'hand' || evt.altKey || evt.button === 1) {
                state.isPanning = true;
                canvas.selection = false;
                state.lastPosX = evt.clientX;
                state.lastPosY = evt.clientY;
                canvas.setCursor('grabbing');
            }
        });

        canvas.on('mouse:move', (opt) => {
            const e = opt.e;

            // Sync any workflow nodes
            canvas.getObjects('workflow-node').forEach(node => node.syncDOM());

            if (state.isPanning) {
                const vpt = canvas.viewportTransform;
                vpt[4] += e.clientX - state.lastPosX;
                vpt[5] += e.clientY - state.lastPosY;
                canvas.requestRenderAll();
                state.lastPosX = e.clientX;
                state.lastPosY = e.clientY;
            } else if (state.activeArrow) {
                const pointer = canvas.getPointer(e);
                state.activeArrow.evented = false;
                const target = canvas.findTarget(e);
                state.activeArrow.evented = true;

                state.activeArrow.set({ x2: pointer.x, y2: pointer.y });

                if (target && target !== state.activeArrow && target !== state.activeArrow.startObj) {
                    const port = getNearestPort(target, pointer);
                    state.activeArrow.set({ x2: port.x, y2: port.y });
                }

                updateArrow(state.activeArrow);
                canvas.renderAll();
            }
        });

        canvas.on('mouse:dblclick', (opt) => {
            if (!opt.target) {
                if (state.currentTool === 'select') {
                    const pointer = canvas.getPointer(opt.e);
                    const text = new fabric.IText('Text', {
                        left: pointer.x,
                        top: pointer.y,
                        fontFamily: 'Inter',
                        fontSize: 24,
                        fill: state.currentColor,
                        originX: 'center',
                        originY: 'center'
                    });
                    canvas.add(text);
                    canvas.setActiveObject(text);
                    text.enterEditing();
                    saveState();
                }
                return;
            }

            if (opt.target.type === 'workflow-node' || opt.target.type === 'markdown-block') {
                sidebar.classList.remove('hidden');
                updateSidebarFromSelection();
                document.getElementById('edit-textarea').focus();
            }
        });

        canvas.on('mouse:up', (opt) => {
            if (state.activeArrow) {
                const pointer = canvas.getPointer(opt.e);
                const target = canvas.findTarget(opt.e);

                if (target && target !== state.activeArrow && target !== state.activeArrow.startObj) {
                    const port = getNearestPort(target, pointer);
                    state.activeArrow.set({
                        endObj: target,
                        endPort: port.id
                    });
                    updateArrow(state.activeArrow);
                }

                state.activeArrow = null;
                setTool('select');
                saveState();
                clearPorts();
            }
            state.isPanning = false;
            canvas.selection = state.currentTool === 'select';
        });

        // --- History (Undo/Redo) ---

        function saveState() {
            if (state.isHistoryAction) return;

            prepareForSave();
            const json = JSON.stringify(canvas.toDatalessJSON([
                'id', 'x1', 'y1', 'x2', 'y2',
                'startObjId', 'endObjId',
                'startPort', 'endPort',
                'arrowType', 'workflowData', 'fontSize',
                'lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'hasControls', 'editable',
                'type'
            ]));

            if (state.historyIndex === -1 || state.history[state.historyIndex] !== json) {
                state.history = state.history.slice(0, state.historyIndex + 1);
                state.history.push(json);
                state.historyIndex++;

                if (state.history.length > 50) {
                    state.history.shift();
                    state.historyIndex--;
                }

                updateUndoRedoButtons();
            }
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.isHistoryAction = true;
                state.historyIndex--;
                loadStateFromJSON(state.history[state.historyIndex]);
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.isHistoryAction = true;
                state.historyIndex++;
                loadStateFromJSON(state.history[state.historyIndex]);
            }
        }

        function loadStateFromJSON(json) {
            const currentOverlayIds = canvas.getObjects('workflow-node').map(n => 'node-overlay-' + n.id);

            canvas.loadFromJSON(json, () => {
                const newOverlayIds = canvas.getObjects('workflow-node').map(n => 'node-overlay-' + n.id);

                document.querySelectorAll('.workflow-overlay').forEach(el => {
                    if (!newOverlayIds.includes(el.id)) el.remove();
                });

                canvas.getObjects('polyline').forEach(arrow => updateArrow(arrow));

                canvas.getObjects('workflow-node').forEach(node => {
                    node.createDOMElement();
                    const currentWorkflowAttr = node.domElement.getAttribute('workflow');
                    const newWorkflowAttr = JSON.stringify(node.workflowData);
                    if (currentWorkflowAttr !== newWorkflowAttr) {
                        node.domElement.setAttribute('workflow', newWorkflowAttr);
                    }
                    node.syncDOM();
                });

                canvas.renderAll();
                state.isHistoryAction = false;
                updateUndoRedoButtons();
            });
        }

        // --- Persistence ---

        function prepareForSave() {
            canvas.getObjects('polyline').forEach(arrow => {
                if (arrow.startObj) arrow.startObjId = arrow.startObj.id;
                if (arrow.endObj) arrow.endObjId = arrow.endObj.id;
            });
        }

        async function exportPNG() {
            // Web components like <n8n-demo> are not part of the canvas bitmap.
            // We need to temporarily render them into SVG images that Fabric can rasterize.
            const workflowNodes = canvas.getObjects('workflow-node');
            const placeholders = [];

            for (const node of workflowNodes) {
                // n8n-demo is too complex for simple SVG foreignObject in some browsers
                // but we can try to grab its SVG internal representation if available,
                // or just draw a high-quality placeholder.
                // Since this is a static tool, we'll use a reliable fallback:
                // We'll draw the node's visual state onto a temporary canvas if possible.

                // For now, let's improve the SVG representation of these nodes
                const rect = new fabric.Rect({
                    left: node.left, top: node.top, width: node.width, height: node.height,
                    fill: '#121212', stroke: '#FF6C37', strokeWidth: 2, rx: 15, ry: 15,
                    angle: node.angle, scaleX: node.scaleX, scaleY: node.scaleY, originX: 'center', originY: 'center'
                });

                const label = new fabric.Text("n8n Workflow Preview", {
                    left: node.left, top: node.top, fontSize: 16, fill: '#FF6C37',
                    angle: node.angle, originX: 'center', originY: 'center'
                });

                canvas.add(rect, label);
                placeholders.push(rect, label);
            }

            canvas.renderAll();

            const dataURL = canvas.toDataURL({ format: 'png', multiplier: 2 });
            const link = document.createElement('a');
            link.download = 'nexus-export.png';
            link.href = dataURL;
            link.click();

            // Cleanup
            placeholders.forEach(p => canvas.remove(p));
            canvas.renderAll();
        }

        function exportSVG() {
            const svg = canvas.toSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'nexus-export.svg';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function exportJSON() {
            prepareForSave();
            const json = JSON.stringify(canvas.toDatalessJSON([
                'id', 'x1', 'y1', 'x2', 'y2',
                'startObjId', 'endObjId',
                'startPort', 'endPort',
                'arrowType', 'workflowData', 'fontSize',
                'lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'hasControls', 'editable',
                'type'
            ]), null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = 'nexus-project.json';
            link.href = url;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importJSON() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (f) => {
                    loadStateFromJSON(f.target.result);
                    saveState();
                };
                reader.readAsText(file);
            };
            input.click();
        }


        function handleImageBtn() {
            // Toggle sidebar to Assets section
            sidebar.classList.remove('hidden');
            document.getElementById('image-section').scrollIntoView({ behavior: 'smooth' });
            const btn = document.getElementById('sidebar-upload-btn');
            btn.style.borderColor = 'var(--accent-color)';
            setTimeout(() => btn.style.borderColor = 'var(--panel-border)', 1000);
        }

        function handleImageUrl() {
            const url = prompt("Enter Image URL:");
            if (url && url.trim()) {
                fabric.Image.fromURL(url.trim(), img => {
                    if (img.width && img.height) {
                        img.scaleToWidth(Math.min(400, window.innerWidth * 0.4));
                        canvas.add(img).centerObject(img).setActiveObject(img);
                        setTool('select');
                        saveState();
                    }
                }, {
                    crossOrigin: 'anonymous',
                    onError: () => alert('Could not load image. Check URL and CORS.')
                });
            }
        }

        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                alert('Please select a valid image file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = f => {
                fabric.Image.fromURL(f.target.result, img => {
                    if (img.width && img.height) {
                        img.scaleToWidth(Math.min(300, window.innerWidth * 0.3));
                        canvas.add(img).centerObject(img).setActiveObject(img);
                        setTool('select');
                        saveState();
                    }
                });
            };
            reader.onerror = () => {
                alert('Failed to read the image file.');
            };
            reader.readAsDataURL(file);
        }

        // --- Fabric Events ---
        canvas.on('selection:created', () => {
            sidebar.classList.remove('hidden');
            updateSidebarFromSelection();
        });
        canvas.on('selection:updated', () => {
            sidebar.classList.remove('hidden');
            updateSidebarFromSelection();
        });
        canvas.on('selection:cleared', () => {
            if (!document.getElementById('sidebar').classList.contains('library-open')) {
                sidebar.classList.add('hidden');
            }
            document.getElementById('text-options').style.display = 'none';
        });

        function updateUndoRedoButtons() {
            document.getElementById('undo-btn').style.opacity = (state.historyIndex > 0) ? '1' : '0.3';
            document.getElementById('redo-btn').style.opacity = (state.historyIndex < state.history.length - 1) ? '1' : '0.3';
        }

        function updateSidebarFromSelection() {
            const obj = canvas.getActiveObject();
            const editSection = document.getElementById('edit-section');
            const editTitle = document.getElementById('edit-title');
            const editTextarea = document.getElementById('edit-textarea');

            if (!obj) {
                editSection.style.display = 'none';
                return;
            }

            // Show Edit Section for Workflow
            if (obj.type === 'workflow-node') {
                editSection.style.display = 'block';
                editTitle.textContent = 'Edit Workflow JSON';
                editTextarea.value = JSON.stringify(obj.workflowData, null, 2);
            } else {
                editSection.style.display = 'none';
            }


            if (obj.strokeWidth) strokeWidthInput.value = obj.strokeWidth;
            if (obj.opacity !== undefined) opacityInput.value = obj.opacity * 100;

            const isLocked = !!obj.lockMovementX;
            const lockBtn = document.getElementById('lock-btn');
            lockBtn.innerHTML = isLocked ? '<i data-lucide="lock"></i>' : '<i data-lucide="unlock"></i>';
            lockBtn.classList.toggle('active', isLocked);
            lucide.createIcons();

            if (obj.strokeDashArray) {
                if (obj.strokeDashArray[0] === 10) strokeDashInput.value = 'dashed';
                else if (obj.strokeDashArray[0] === 2) strokeDashInput.value = 'dotted';
                else strokeDashInput.value = 'solid';
            } else {
                strokeDashInput.value = 'solid';
            }

            if (obj.type === 'i-text' || obj.type === 'text') {
                document.getElementById('text-options').style.display = 'block';
                fontFamilyInput.value = obj.fontFamily || 'Inter';
                const textColor = obj.fill;
                if (textColor && typeof textColor === 'string') {
                    setColor(textColor, false);
                }
            } else {
                document.getElementById('text-options').style.display = 'none';
                if (obj.type !== 'activeSelection') {
                    const color = obj.stroke || obj.fill;
                    if (color && typeof color === 'string') {
                        setColor(color, false);
                    }
                }
            }
        }

        canvas.on('mouse:down', (opt) => {
            if (state.currentTool === 'select' || state.currentTool === 'pencil' || state.currentTool === 'hand' || state.currentTool === 'eraser') return;
            if (opt.button === 3) return;

            const pointer = canvas.getPointer(opt.e);
            let obj;
            const strokeWidth = parseInt(strokeWidthInput.value) || 2;
            const common = {
                left: pointer.x,
                top: pointer.y,
                stroke: state.currentColor,
                strokeWidth: strokeWidth,
                fill: state.currentColor === 'transparent' ? 'transparent' : state.currentColor + '33',
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true
            };

            if (state.currentTool === 'rect') {
                obj = new fabric.Rect({ ...common, width: 100, height: 100, rx: 5, ry: 5 });
            } else if (state.currentTool === 'frame') {
                const rect = new fabric.Rect({
                    width: 400,
                    height: 250,
                    fill: 'rgba(59, 130, 246, 0.05)',
                    stroke: '#3b82f6',
                    strokeWidth: 2,
                    strokeDashArray: [10, 5],
                    rx: 10,
                    ry: 10,
                    originX: 'center',
                    originY: 'center'
                });
                const label = new fabric.Text("SLIDE", {
                    fontSize: 10,
                    fontFamily: 'Inter',
                    fontWeight: 800,
                    fill: '#3b82f6',
                    top: -115,
                    left: -175,
                    originX: 'center',
                    originY: 'center'
                });
                obj = new fabric.Group([rect, label], {
                    ...common,
                    type: 'slide-frame',
                    subTargetCheck: false
                });
            } else if (state.currentTool === 'circle') {
                obj = new fabric.Circle({ ...common, radius: 50 });
            } else if (state.currentTool === 'triangle') {
                obj = new fabric.Triangle({ ...common, width: 100, height: 100 });
            } else if (state.currentTool === 'diamond') {
                obj = new fabric.Rect({ ...common, width: 80, height: 80, angle: 45 });
            } else if (state.currentTool === 'hexagon') {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = i * Math.PI / 3;
                    points.push({ x: 50 * Math.cos(angle), y: 50 * Math.sin(angle) });
                }
                obj = new fabric.Polygon(points, { ...common });
            } else if (state.currentTool === 'text') {
                obj = new fabric.IText('Type something...', {
                    ...common,
                    fill: state.currentColor,
                    fontSize: 24,
                    fontFamily: fontFamilyInput.value || 'Inter',
                    stroke: 'transparent',
                    strokeWidth: 0,
                    objectCaching: false
                });
            } else if (state.currentTool === 'workflow') {
                obj = new fabric.WorkflowNode({ nodes: [], connections: {} }, {
                    left: pointer.x,
                    top: pointer.y
                });
            } else if (state.currentTool === 'arrow') {
                const target = canvas.findTarget(opt.e);
                let startX = pointer.x, startY = pointer.y;
                let startObj = null, startPort = null;

                if (target) {
                    const port = getNearestPort(target, pointer);
                    startX = port.x;
                    startY = port.y;
                    startObj = target;
                    startPort = port.id;
                }

                const arrow = createArrow(startX, startY);
                arrow.set({ startObj, startPort });
                state.activeArrow = arrow;
                canvas.add(arrow);
                canvas.setActiveObject(arrow);
                canvas.renderAll();
                return;
            }

            if (obj) {
                setTool('select');
                canvas.add(obj);
                canvas.setActiveObject(obj);
                canvas.requestRenderAll();
                saveState();
            }
        });

        // Keyboard Shortcuts
        window.onkeydown = (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
                if (e.key === 'x' && e.shiftKey) { e.preventDefault(); clearCanvas(); }
                return;
            }

            switch (e.key.toLowerCase()) {
                case 'v': setTool('select'); break;
                case 'h': setTool('hand'); break;
                case 't': setTool('text'); break;
                case 'w': setTool('workflow'); break;
                case 'l': document.getElementById('library-toggle').click(); break;
                case 'r': setTool('rect'); break;
                case 'o': setTool('circle'); break;
                case 'a': setTool('arrow'); break;
                case 'p': setTool('pencil'); break;
                case 'e': setTool('eraser'); break;
                case 'delete':
                case 'backspace': deleteSelected(); break;
            }
        };

        // Initialize Everything
        initUI();
        setTool('select');

        if (document.fonts) {
            document.fonts.ready.then(() => {
                canvas.renderAll();
            });
        }

        window.addEventListener('load', () => {
            setTimeout(() => {
                if (state.history.length === 0) {
                    saveState();
                }
            }, 100);
        });

        let modificationTimeout;
        const debouncedSaveState = () => {
            clearTimeout(modificationTimeout);
            modificationTimeout = setTimeout(saveState, 100);
        };

        canvas.on('object:moving', (e) => {
            const target = e.target;
            if (state.grid) {
                target.set({
                    left: Math.round(target.left / state.grid) * state.grid,
                    top: Math.round(target.top / state.grid) * state.grid
                });
            }
            // Update arrows and DOM in a single pass
            updateConnectedArrows(target);
            if (target.type === 'workflow-node') target.syncDOM();

            // If dragging a selection, sync all children
            if (target.type === 'activeSelection') {
                target.getObjects().forEach(obj => {
                    updateConnectedArrows(obj);
                    if (obj.type === 'workflow-node') obj.syncDOM();
                });
            }
        });

        canvas.on('object:scaling', (e) => {
            const target = e.target;
            if (state.grid) {
                const width = target.width * target.scaleX;
                const height = target.height * target.scaleY;
                const snapWidth = Math.round(width / state.grid) * state.grid;
                const snapHeight = Math.round(height / state.grid) * state.grid;
                target.set({
                    scaleX: snapWidth / target.width,
                    scaleY: snapHeight / target.height
                });
            }
            updateConnectedArrows(target);
            if (target.type === 'workflow-node') target.syncDOM();

            if (target.type === 'activeSelection') {
                target.getObjects().forEach(obj => {
                    updateConnectedArrows(obj);
                    if (obj.type === 'workflow-node') obj.syncDOM();
                });
            }
        });
        canvas.on('object:rotating', (e) => {
            updateConnectedArrows(e.target);
            if (e.target.type === 'workflow-node') e.target.syncDOM();
        });

        canvas.on('object:modified', debouncedSaveState);
        canvas.on('object:added', (opt) => {
            const obj = opt.target;
            if (!obj.id) obj.id = generateId();

            if (!state.isHistoryAction) {
                emptyState.style.display = 'none';
                debouncedSaveState();
            }
        });
        canvas.on('object:removed', (opt) => {
            const obj = opt.target;

            // Remove connected arrows
            const arrows = canvas.getObjects('polyline').filter(a => a.startObj === obj || a.endObj === obj);
            if (arrows.length > 0) {
                canvas.remove(...arrows);
            }

            if (!state.isHistoryAction) {
                debouncedSaveState();
            }
        });

        // Handle text editing mode
        canvas.on('text:editing:entered', (e) => {
            const textObj = e.target;
            // Ensure text color is preserved during editing
            if (textObj.fill) {
                textObj.set('stroke', 'transparent');
                textObj.set('strokeWidth', 0);
            }
        });

        canvas.on('text:editing:exited', (e) => {
            const textObj = e.target;
            // Ensure text properties are correct after editing
            textObj.set('stroke', 'transparent');
            textObj.set('strokeWidth', 0);
            canvas.renderAll();
            saveState();
        });

        // Helper to draw visual ports
        function drawPorts(obj) {
            if (!obj || obj.type === 'polyline' || obj.name === 'port-helper') return;
            ports.forEach(p => {
                const coords = getPortCoords(obj, p.id);
                const circle = new fabric.Circle({
                    left: coords.x,
                    top: coords.y,
                    radius: 4,
                    fill: '#0077FF',
                    stroke: '#FFFFFF',
                    strokeWidth: 1,
                    originX: 'center',
                    originY: 'center',
                    selectable: false,
                    evented: false,
                    name: 'port-helper'
                });
                canvas.add(circle);
            });
            canvas.renderAll();
        }

        function clearPorts() {
            const helpers = canvas.getObjects().filter(o => o.name === 'port-helper');
            canvas.remove(...helpers);
            canvas.renderAll();
        }

        canvas.on('mouse:over', (e) => {
            if (state.currentTool === 'arrow' && e.target) {
                drawPorts(e.target);
            }
        });

        canvas.on('mouse:out', (e) => {
            if (state.currentTool === 'arrow') {
                clearPorts();
            }
        });

        // Better error handling for canvas operations
        canvas.on('error', (e) => {
            console.error('Canvas error:', e);
            saveStatusText.textContent = 'Error occurred';
        });
    </script>
</body>

</html>